/**
 * Test Compile Command
 */

const path = require('path');
const fs = require('fs').promises;
const BuildCommand = require('../../lib/BuildCommand');

/**
 * Compile tests for execution
 * Uses the existing MigrationCompiler but configured for test directory
 */
class CompileCommand extends BuildCommand {
  constructor(
    testsDir,
    outputDir,
    logger = null,
    isProd = false
  ) {
    super(testsDir, outputDir, logger, isProd);

    // Validate paths are provided
    if (!this.inputDir || !this.outputDir) {
      throw new Error('CompileCommand requires test directory and output directory');
    }
  }

  /**
   * Execute test compilation
   */
  async performExecute() {
    this.emit('compilation:start', { isProd: this.isProd, type: 'test' });

    try {
      this.progress('Starting test compilation...');

      // Validate test directory structure
      await this.validateTestDirectory();

      // TODO: Implement native test compilation
      // The legacy build system has been removed. This command needs to be reimplemented
      // using a native test compiler approach
      throw new Error('Test compilation not yet implemented. Legacy build system has been removed.');

      // Validate pgTAP function signatures
      await this.validatePgTapFunctions(result.outputFile);

      this.success(`Test compilation completed: ${result.outputFile}`);
      this.emit('compilation:complete', {
        result,
        type: 'test',
        testsCompiled: result.stats.filesProcessed
      });

      return result;
    } catch (error) {
      this.error('Test compilation failed', error);
      this.emit('compilation:failed', { error, type: 'test' });
      throw error;
    }
  }

  /**
   * Validate that test directory exists and has test files
   */
  async validateTestDirectory() {
    // Get test directory from OutputConfig
    const testDir = this.inputDir;

    try {
      const stat = await fs.stat(testDir);
      if (!stat.isDirectory()) {
        throw new Error(`Tests path is not a directory: ${testDir}`);
      }

      // Use glob to recursively find SQL files
      const { glob } = require('glob');
      const pattern = path.join(testDir, '**/*.sql');
      const sqlFiles = await glob(pattern);

      if (sqlFiles.length === 0) {
        throw new Error(`No SQL test files found in: ${testDir}`);
      }

      this.progress(`Found ${sqlFiles.length} test files in ${testDir}`);
    } catch (error) {
      if (error.code === 'ENOENT') {
        throw new Error(`Test directory not found: ${testDir}`);
      }
      throw error;
    }
  }

  /**
   * Configure the compiler for test-specific compilation
   */
  async configureTestCompiler(compiler) {
    // Override the filename generator to create test-specific migration
    compiler.generateOutputFilename = () => {
      const timestamp = new Date()
        .toISOString()
        .replace(/[T:]/g, '')
        .replace(/\..+/, '')
        .replace(/-/g, '')
        .slice(0, 14);

      return path.join(compiler.config.outputDir, `${timestamp}_compiled_tests.sql`);
    };

    // Override the header to indicate this is a test compilation
    const originalWriteHeader = compiler.writeHeader.bind(compiler);
    compiler.writeHeader = async (outputFile) => {
      const header = `-- =========================================================================
-- COMPILED TEST MIGRATION - Generated from pgTAP test sources
-- =========================================================================
-- 
-- ⛰️ Generated by data's Test Compilation System
-- Following enterprise patterns for database-centric testing architectures
-- 
-- DO NOT EDIT THIS FILE DIRECTLY
-- Edit source files in /supabase/tests/ and recompile
-- 
-- Generated: ${new Date().toISOString()}
-- Source: pgTAP test files in dependency order
-- =========================================================================

`;

      await fs.writeFile(outputFile, header);
      compiler.stats.linesWritten += header.split('\n').length;

      compiler.emit('header:written', {
        outputFile,
        lines: header.split('\n').length
      });
    };
  }

  /**
   * Compile the test directory using a custom approach
   */
  async compileTestDirectory(compiler) {
    compiler.stats.startTime = new Date();

    compiler.emit('start', {
      timestamp: compiler.stats.startTime,
      config: compiler.config,
      type: 'test'
    });

    // Validate test directory exists
    const testDir = this.inputDir;
    await fs.stat(testDir);

    // Ensure output directory exists
    await fs.mkdir(compiler.config.outputDir, { recursive: true });

    // Generate output filename
    const outputFile = compiler.generateOutputFilename();

    // Write header
    await compiler.writeHeader(outputFile);

    // Get all SQL files in tests directory
    const files = await fs.readdir(testDir);
    const sqlFiles = files
      .filter(f => f.endsWith('.sql'))
      .sort(); // Sort for consistent ordering (important for test setup)

    this.emit('compilation:progress', {
      stage: 'processing_files',
      totalFiles: sqlFiles.length
    });

    // Process each test file
    for (const sqlFile of sqlFiles) {
      await this.processTestFile(testDir, sqlFile, outputFile, compiler);
    }

    // Write footer with test-specific instructions
    await this.writeTestFooter(outputFile, compiler);

    // Complete
    compiler.stats.endTime = new Date();
    const duration = compiler.stats.endTime - compiler.stats.startTime;

    compiler.emit('complete', {
      outputFile,
      filesProcessed: compiler.stats.filesProcessed,
      linesWritten: compiler.stats.linesWritten,
      duration,
      timestamp: compiler.stats.endTime,
      type: 'test'
    });

    return {
      success: true,
      outputFile,
      stats: compiler.stats
    };
  }

  /**
   * Process a single test file
   */
  async processTestFile(testDir, filename, outputFile, compiler) {
    const filePath = path.join(testDir, filename);

    try {
      compiler.emit('file:start', {
        file: filename,
        path: filePath
      });

      // Read file content
      const content = await fs.readFile(filePath, 'utf8');

      // Validate pgTAP function structure
      await this.validateTestFileContent(content, filename);

      // Write file section with test-specific formatting
      const fileSection = `-- =========================================================================
-- TEST FILE: ${filename}
-- =========================================================================
${content}

`;

      await fs.appendFile(outputFile, fileSection);

      const linesAdded = fileSection.split('\n').length;
      compiler.stats.linesWritten += linesAdded;
      compiler.stats.filesProcessed++;

      compiler.emit('file:complete', {
        file: filename,
        lines: linesAdded,
        size: content.length
      });

      this.emit('compilation:progress', {
        stage: 'file_processed',
        file: filename,
        processedCount: compiler.stats.filesProcessed
      });

    } catch (error) {
      compiler.emit('file:error', {
        file: filename,
        error: error.message
      });
      throw error;
    }
  }

  /**
   * Validate test file content for pgTAP structure
   */
  async validateTestFileContent(content, filename) {
    // Check for required pgTAP function patterns
    const lines = content.split('\n');

    // Look for test function definitions
    const testFunctionPattern = /CREATE\s+OR\s+REPLACE\s+FUNCTION\s+test\.([a-zA-Z0-9_]+)\s*\(\s*\)/i;
    const tapPlanPattern = /tap\.plan\s*\(\s*(\d+)\s*\)/i;
    const tapFinishPattern = /tap\.finish\s*\(\s*\)/i;

    let hasTestFunction = false;
    let hasTapPlan = false;
    let hasTapFinish = false;

    for (const line of lines) {
      if (testFunctionPattern.test(line)) {
        hasTestFunction = true;
      }
      if (tapPlanPattern.test(line)) {
        hasTapPlan = true;
      }
      if (tapFinishPattern.test(line)) {
        hasTapFinish = true;
      }
    }

    // Emit warnings for missing pgTAP patterns (non-fatal)
    if (!hasTestFunction) {
      this.warn(`${filename}: No test functions found - may not be a pgTAP test file`);
    }
    if (hasTestFunction && !hasTapPlan) {
      this.warn(`${filename}: Missing tap.plan() call - tests may not run correctly`);
    }
    if (hasTestFunction && !hasTapFinish) {
      this.warn(`${filename}: Missing tap.finish() call - tests may not complete properly`);
    }
  }

  /**
   * Write test-specific footer
   */
  async writeTestFooter(outputFile, compiler) {
    const footer = `
-- =========================================================================
-- END OF COMPILED TEST MIGRATION
-- =========================================================================
-- 
-- To run these tests:
-- 1. Deploy this migration: npx supabase db reset
-- 2. Run tests: psql [connection] -c "SELECT * FROM test.run_all_tests()"
-- 3. Or run individual tests: psql [connection] -c "SELECT * FROM test.run_[test_name]()"
-- 
-- To modify tests:
-- 1. Edit files in /supabase/tests/
-- 2. Recompile: ./build/data test compile
-- 3. Redeploy: npx supabase db reset
-- 
-- =========================================================================
`;

    await fs.appendFile(outputFile, footer);
    compiler.stats.linesWritten += footer.split('\n').length;

    compiler.emit('footer:written', {
      lines: footer.split('\n').length
    });
  }

  /**
   * Validate pgTAP function signatures in the compiled output
   */
  async validatePgTapFunctions(outputFile) {
    this.progress('Validating pgTAP function signatures...');

    try {
      const content = await fs.readFile(outputFile, 'utf8');

      // Look for all test function definitions
      const testFunctionPattern = /CREATE\s+OR\s+REPLACE\s+FUNCTION\s+test\.([a-zA-Z0-9_]+)\s*\(\s*\)/gi;
      const functions = [];
      let match;

      while ((match = testFunctionPattern.exec(content)) !== null) {
        functions.push(match[1]);
      }

      if (functions.length === 0) {
        this.warn('No pgTAP test functions found in compiled output');
      } else {
        this.success(`Validated ${functions.length} pgTAP test functions: ${functions.join(', ')}`);
      }

      // Validate that each function has proper pgTAP structure
      for (const func of functions) {
        const funcRegex = new RegExp(`CREATE\\s+OR\\s+REPLACE\\s+FUNCTION\\s+test\\.${func}[\\s\\S]*?\\$\\$;`, 'i');
        const funcMatch = content.match(funcRegex);

        if (funcMatch) {
          const funcBody = funcMatch[0];
          if (!funcBody.includes('RETURNS SETOF TEXT')) {
            this.warn(`Function test.${func} may not return SETOF TEXT - required for pgTAP`);
          }
          if (!funcBody.includes('tap.plan(')) {
            this.warn(`Function test.${func} missing tap.plan() - tests may not execute properly`);
          }
        }
      }

    } catch (error) {
      this.warn(`Could not validate pgTAP functions: ${error.message}`);
    }
  }

  /**
   * Attach event listeners to the test compiler
   */
  attachTestCompilerEvents(compiler) {
    compiler.on('start', ({ timestamp, type }) => {
      this.logger.debug({ timestamp, type }, 'Test compilation started');
    });

    compiler.on('file:start', ({ file }) => {
      this.progress(`Processing test file: ${file}`);
    });

    compiler.on('file:complete', ({ file, lines }) => {
      this.logger.debug({ file, lines }, 'Test file processed');
    });

    compiler.on('file:error', ({ file, error }) => {
      this.error(`Error processing test file ${file}`, error);
    });

    compiler.on('complete', ({ stats, type }) => {
      this.logger.info({ stats, type }, 'Test compilation complete');
    });

    compiler.on('error', ({ error }) => {
      this.error('Test compiler error', error);
    });
  }
}

module.exports = CompileCommand;
