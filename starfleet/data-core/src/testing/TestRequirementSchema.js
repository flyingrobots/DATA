/**
 * Test Requirement Schema - JSDoc Type Definitions
 *
 * This file defines comprehensive type schemas for test coverage enforcement
 * in the D.A.T.A. project. These types are used throughout the test coverage
 * analysis and enforcement system to ensure pgTAP test completeness.
 *
 * @fileoverview JSDoc type definitions for test requirements and coverage analysis
 */

/**
 * Priority levels for test requirements
 * @typedef {'critical' | 'high' | 'medium' | 'low'} TestPriority
 */

/**
 * Types of database objects that can be tested
 * @typedef {'table' | 'column' | 'function' | 'index' | 'policy' | 'trigger' | 'schema' | 'view' | 'constraint'} DatabaseObjectType
 */

/**
 * pgTAP assertion function names
 * @typedef {'has_table' | 'hasnt_table' | 'has_view' | 'hasnt_view' | 'has_column' | 'hasnt_column' | 'col_type_is' | 'col_is_null' | 'col_not_null' | 'col_has_default' | 'col_default_is' | 'has_function' | 'hasnt_function' | 'function_returns' | 'has_index' | 'hasnt_index' | 'index_is_unique' | 'has_pk' | 'hasnt_pk' | 'has_fk' | 'hasnt_fk' | 'fk_ok' | 'has_check' | 'hasnt_check' | 'check_test' | 'has_trigger' | 'hasnt_trigger' | 'trigger_is' | 'policy_roles_are' | 'policy_cmd_is' | 'results_eq' | 'results_ne' | 'set_eq' | 'bag_eq' | 'is' | 'isnt' | 'ok' | 'nok' | 'pass' | 'fail'} PgTapAssertion
 */

/**
 * Base metadata for all test requirements
 * @typedef {Object} BaseTestMetadata
 * @property {string} [description] - Human-readable description of what should be tested
 * @property {string[]} [tags] - Tags for categorizing tests (e.g., ['migration', 'security'])
 * @property {string} [source] - Source of the requirement (e.g., 'migration', 'schema_analysis')
 * @property {number} [estimatedEffort] - Estimated effort to implement test (1-10 scale)
 * @property {string[]} [dependencies] - Other requirements this depends on
 * @property {boolean} [autoGenerated] - Whether this requirement was auto-generated
 * @property {Date} [createdAt] - When requirement was identified
 * @property {string} [version] - Schema version when requirement was created
 */

/**
 * Base test requirement object - foundation for all specific requirement types
 * @typedef {Object} TestRequirement
 * @property {string} id - Unique identifier for the requirement
 * @property {DatabaseObjectType} objectType - Type of database object being tested
 * @property {string} targetName - Name of the target object (table, column, function, etc.)
 * @property {PgTapAssertion[]} requiredAssertions - List of pgTAP assertions that must be present
 * @property {TestPriority} priority - Importance level of this test requirement
 * @property {BaseTestMetadata} metadata - Additional metadata about the requirement
 * @property {string} [schema] - Database schema name (defaults to 'public')
 * @property {boolean} [optional] - Whether this requirement is optional
 */

/**
 * Test requirement for database tables
 * @typedef {Object} TableTestRequirement
 * @property {string} id - Unique identifier for the requirement
 * @property {'table'} objectType - Always 'table' for table requirements
 * @property {string} targetName - Name of the table to test
 * @property {PgTapAssertion[]} requiredAssertions - Required assertions (e.g., ['has_table', 'has_pk'])
 * @property {TestPriority} priority - Importance level
 * @property {TableTestMetadata} metadata - Table-specific metadata
 * @property {string} [schema] - Schema name (defaults to 'public')
 * @property {boolean} [optional] - Whether this requirement is optional
 */

/**
 * Metadata specific to table test requirements
 * @typedef {BaseTestMetadata & Object} TableTestMetadata
 * @property {ColumnTestRequirement[]} [columns] - Column requirements for this table
 * @property {IndexTestRequirement[]} [indexes] - Index requirements for this table
 * @property {PolicyTestRequirement[]} [policies] - RLS policy requirements for this table
 * @property {TriggerTestRequirement[]} [triggers] - Trigger requirements for this table
 * @property {boolean} [requiresRowLevelSecurity] - Whether RLS should be tested
 * @property {string[]} [expectedConstraints] - Names of constraints that should exist
 * @property {number} [expectedRowCount] - Expected number of rows (for validation)
 */

/**
 * Test requirement for table columns
 * @typedef {Object} ColumnTestRequirement
 * @property {string} id - Unique identifier for the requirement
 * @property {'column'} objectType - Always 'column' for column requirements
 * @property {string} targetName - Name of the column to test
 * @property {string} tableName - Name of the parent table
 * @property {PgTapAssertion[]} requiredAssertions - Required assertions (e.g., ['has_column', 'col_type_is'])
 * @property {TestPriority} priority - Importance level
 * @property {ColumnTestMetadata} metadata - Column-specific metadata
 * @property {string} [schema] - Schema name (defaults to 'public')
 * @property {boolean} [optional] - Whether this requirement is optional
 */

/**
 * Metadata specific to column test requirements
 * @typedef {BaseTestMetadata & Object} ColumnTestMetadata
 * @property {string} [expectedType] - Expected column data type
 * @property {boolean} [expectedNotNull] - Whether column should be NOT NULL
 * @property {boolean} [expectedHasDefault] - Whether column should have a default value
 * @property {*} [expectedDefaultValue] - Expected default value
 * @property {boolean} [isPrimaryKey] - Whether column is part of primary key
 * @property {boolean} [isForeignKey] - Whether column is a foreign key
 * @property {string} [referencedTable] - Referenced table if foreign key
 * @property {string} [referencedColumn] - Referenced column if foreign key
 * @property {number} [maxLength] - Maximum length for string columns
 * @property {boolean} [isUnique] - Whether column has unique constraint
 */

/**
 * Test requirement for database functions/procedures
 * @typedef {Object} FunctionTestRequirement
 * @property {string} id - Unique identifier for the requirement
 * @property {'function'} objectType - Always 'function' for function requirements
 * @property {string} targetName - Name of the function to test
 * @property {PgTapAssertion[]} requiredAssertions - Required assertions (e.g., ['has_function', 'function_returns'])
 * @property {TestPriority} priority - Importance level
 * @property {FunctionTestMetadata} metadata - Function-specific metadata
 * @property {string} [schema] - Schema name (defaults to 'public')
 * @property {boolean} [optional] - Whether this requirement is optional
 */

/**
 * Metadata specific to function test requirements
 * @typedef {BaseTestMetadata & Object} FunctionTestMetadata
 * @property {string[]} [parameterTypes] - Expected parameter types
 * @property {string} [returnType] - Expected return type
 * @property {boolean} [isRpcFunction] - Whether function is exposed via RPC
 * @property {boolean} [requiresSecurityTesting] - Whether security should be tested
 * @property {Object[]} [testCases] - Specific test cases to validate
 * @property {*} testCases[].input - Input parameters for test case
 * @property {*} testCases[].expectedOutput - Expected output for test case
 * @property {string} [testCases[].description] - Description of test case
 * @property {boolean} [isVolatile] - Whether function has side effects
 * @property {string} [language] - Function language (plpgsql, sql, etc.)
 */

/**
 * Test requirement for database indexes
 * @typedef {Object} IndexTestRequirement
 * @property {string} id - Unique identifier for the requirement
 * @property {'index'} objectType - Always 'index' for index requirements
 * @property {string} targetName - Name of the index to test
 * @property {string} tableName - Name of the indexed table
 * @property {PgTapAssertion[]} requiredAssertions - Required assertions (e.g., ['has_index', 'index_is_unique'])
 * @property {TestPriority} priority - Importance level
 * @property {IndexTestMetadata} metadata - Index-specific metadata
 * @property {string} [schema] - Schema name (defaults to 'public')
 * @property {boolean} [optional] - Whether this requirement is optional
 */

/**
 * Metadata specific to index test requirements
 * @typedef {BaseTestMetadata & Object} IndexTestMetadata
 * @property {string[]} [indexedColumns] - Columns included in the index
 * @property {boolean} [isUnique] - Whether index enforces uniqueness
 * @property {boolean} [isPartial] - Whether index is partial (has WHERE clause)
 * @property {string} [whereClause] - WHERE clause for partial indexes
 * @property {string} [indexType] - Index type (btree, hash, gin, gist, etc.)
 * @property {boolean} [isPrimaryKey] - Whether index backs a primary key
 * @property {string} [method] - Index method (btree, hash, etc.)
 * @property {number} [expectedSize] - Expected index size in bytes
 */

/**
 * Test requirement for Row Level Security (RLS) policies
 * @typedef {Object} PolicyTestRequirement
 * @property {string} id - Unique identifier for the requirement
 * @property {'policy'} objectType - Always 'policy' for policy requirements
 * @property {string} targetName - Name of the policy to test
 * @property {string} tableName - Name of the table the policy applies to
 * @property {PgTapAssertion[]} requiredAssertions - Required assertions (e.g., ['policy_roles_are', 'policy_cmd_is'])
 * @property {TestPriority} priority - Importance level
 * @property {PolicyTestMetadata} metadata - Policy-specific metadata
 * @property {string} [schema] - Schema name (defaults to 'public')
 * @property {boolean} [optional] - Whether this requirement is optional
 */

/**
 * Metadata specific to RLS policy test requirements
 * @typedef {BaseTestMetadata & Object} PolicyTestMetadata
 * @property {('SELECT' | 'INSERT' | 'UPDATE' | 'DELETE')[]} [commands] - SQL commands the policy applies to
 * @property {string[]} [roles] - Database roles the policy applies to
 * @property {boolean} [isPermissive] - Whether policy is permissive (vs restrictive)
 * @property {string} [expression] - Policy expression/condition
 * @property {string} [checkExpression] - Policy check expression for INSERT/UPDATE
 * @property {Object[]} [testScenarios] - Security test scenarios
 * @property {string} testScenarios[].role - Role to test with
 * @property {string} testScenarios[].operation - Operation to test
 * @property {boolean} testScenarios[].shouldAllow - Whether operation should be allowed
 * @property {Object} [testScenarios[].context] - Additional context for test
 */

/**
 * Test requirement for database triggers
 * @typedef {Object} TriggerTestRequirement
 * @property {string} id - Unique identifier for the requirement
 * @property {'trigger'} objectType - Always 'trigger' for trigger requirements
 * @property {string} targetName - Name of the trigger to test
 * @property {string} tableName - Name of the table the trigger is on
 * @property {PgTapAssertion[]} requiredAssertions - Required assertions (e.g., ['has_trigger', 'trigger_is'])
 * @property {TestPriority} priority - Importance level
 * @property {TriggerTestMetadata} metadata - Trigger-specific metadata
 * @property {string} [schema] - Schema name (defaults to 'public')
 * @property {boolean} [optional] - Whether this requirement is optional
 */

/**
 * Metadata specific to trigger test requirements
 * @typedef {BaseTestMetadata & Object} TriggerTestMetadata
 * @property {('BEFORE' | 'AFTER' | 'INSTEAD OF')[]} [timing] - When trigger fires
 * @property {('INSERT' | 'UPDATE' | 'DELETE' | 'TRUNCATE')[]} [events] - Events that fire trigger
 * @property {string} [functionName] - Name of trigger function
 * @property {boolean} [isConstraintTrigger] - Whether trigger is a constraint trigger
 * @property {('ROW' | 'STATEMENT')} [level] - Trigger level
 * @property {string} [condition] - WHEN condition for trigger
 * @property {Object[]} [behaviorTests] - Tests for trigger behavior
 * @property {string} behaviorTests[].scenario - Description of test scenario
 * @property {string} behaviorTests[].operation - SQL operation to test
 * @property {*} behaviorTests[].expectedResult - Expected result after trigger fires
 */

/**
 * Represents actual test coverage found during analysis
 * @typedef {Object} TestCoverage
 * @property {string} requirementId - ID of the requirement this coverage addresses
 * @property {DatabaseObjectType} objectType - Type of object covered
 * @property {string} targetName - Name of the covered object
 * @property {PgTapAssertion[]} foundAssertions - pgTAP assertions actually found
 * @property {TestCoverageMetadata} metadata - Coverage analysis metadata
 * @property {boolean} isComplete - Whether all required assertions are present
 * @property {number} coveragePercentage - Percentage of required assertions found (0-100)
 */

/**
 * Metadata for test coverage analysis
 * @typedef {Object} TestCoverageMetadata
 * @property {string} testFilePath - Path to file containing the coverage
 * @property {number[]} lineNumbers - Line numbers where assertions were found
 * @property {string} testFunctionName - Name of test function providing coverage
 * @property {Date} lastAnalyzed - When coverage was last analyzed
 * @property {string} [testSuite] - Name of test suite containing the coverage
 * @property {boolean} [isAutoGenerated] - Whether test was auto-generated
 * @property {string} [gitCommit] - Git commit hash when coverage was analyzed
 * @property {Object.<PgTapAssertion, number[]>} [assertionLocations] - Map of assertions to line numbers
 */

/**
 * Represents a gap in test coverage
 * @typedef {Object} CoverageGap
 * @property {string} requirementId - ID of the requirement missing coverage
 * @property {DatabaseObjectType} objectType - Type of object missing coverage
 * @property {string} targetName - Name of the object missing coverage
 * @property {PgTapAssertion[]} missingAssertions - pgTAP assertions that are missing
 * @property {TestPriority} priority - Priority of the missing coverage
 * @property {CoverageGapMetadata} metadata - Gap analysis metadata
 * @property {number} severityScore - Calculated severity score (0-100)
 */

/**
 * Metadata for coverage gap analysis
 * @typedef {Object} CoverageGapMetadata
 * @property {string} [reason] - Why coverage is missing
 * @property {string[]} [suggestedActions] - Recommended actions to close gap
 * @property {boolean} [canAutoGenerate] - Whether test template can be auto-generated
 * @property {string} [templatePath] - Path to suggested test template
 * @property {Date} identifiedAt - When gap was identified
 * @property {string} [impact] - Description of potential impact if not addressed
 * @property {string[]} [blockedBy] - Other requirements blocking this one
 * @property {number} [estimatedEffort] - Estimated effort to fix (1-10 scale)
 * @property {boolean} [isCriticalPath] - Whether gap is on critical deployment path
 */

/**
 * Configuration for test requirement analysis
 * @typedef {Object} TestRequirementConfig
 * @property {boolean} enforceTableTests - Whether to require tests for all tables
 * @property {boolean} enforceColumnTests - Whether to require tests for all columns
 * @property {boolean} enforceFunctionTests - Whether to require tests for all functions
 * @property {boolean} enforceRlsPolicyTests - Whether to require tests for RLS policies
 * @property {string[]} excludedSchemas - Schemas to exclude from testing requirements
 * @property {string[]} excludedTables - Tables to exclude from testing requirements
 * @property {TestPriority} defaultPriority - Default priority for auto-generated requirements
 * @property {Object.<DatabaseObjectType, PgTapAssertion[]>} requiredAssertions - Default assertions by object type
 * @property {number} minimumCoveragePercentage - Minimum required coverage percentage (0-100)
 * @property {boolean} allowAutoGeneration - Whether to allow auto-generation of test templates
 */

/**
 * Result of test requirement analysis
 * @typedef {Object} TestRequirementAnalysisResult
 * @property {TestRequirement[]} requirements - All identified test requirements
 * @property {TestCoverage[]} coverage - Found test coverage
 * @property {CoverageGap[]} gaps - Identified coverage gaps
 * @property {TestRequirementSummary} summary - Analysis summary
 * @property {Date} analyzedAt - When analysis was performed
 * @property {string} version - Version of analysis engine used
 * @property {Object} metadata - Additional analysis metadata
 */

/**
 * Summary of test requirement analysis
 * @typedef {Object} TestRequirementSummary
 * @property {number} totalRequirements - Total number of requirements identified
 * @property {number} coveredRequirements - Number of requirements with coverage
 * @property {number} uncoveredRequirements - Number of requirements without coverage
 * @property {number} overallCoveragePercentage - Overall coverage percentage
 * @property {Object.<TestPriority, number>} requirementsByPriority - Count by priority level
 * @property {Object.<DatabaseObjectType, number>} requirementsByType - Count by object type
 * @property {Object.<DatabaseObjectType, number>} coverageByType - Coverage count by object type
 * @property {number} criticalGaps - Number of critical priority gaps
 * @property {number} autoGenerableGaps - Number of gaps that can be auto-generated
 * @property {boolean} readyForProduction - Whether coverage meets production standards
 */

// Export all types for use in other modules
export {
  // Type validation helpers - these are runtime functions, not types

  /**
   * Validate a test requirement object
   * @param {any} requirement - Object to validate
   * @returns {boolean} True if valid TestRequirement
   */
  isValidTestRequirement(requirement) {
    return requirement &&
           typeof requirement === 'object' &&
           typeof requirement.id === 'string' &&
           typeof requirement.objectType === 'string' &&
           typeof requirement.targetName === 'string' &&
           Array.isArray(requirement.requiredAssertions) &&
           typeof requirement.priority === 'string' &&
           requirement.metadata && typeof requirement.metadata === 'object';
  },

  /**
   * Validate a coverage gap object
   * @param {any} gap - Object to validate
   * @returns {boolean} True if valid CoverageGap
   */
  isValidCoverageGap(gap) {
    return gap &&
           typeof gap === 'object' &&
           typeof gap.requirementId === 'string' &&
           typeof gap.objectType === 'string' &&
           typeof gap.targetName === 'string' &&
           Array.isArray(gap.missingAssertions) &&
           typeof gap.priority === 'string' &&
           typeof gap.severityScore === 'number';
  },

  /**
   * Create a new test requirement with defaults
   * @param {Partial<TestRequirement>} requirement - Partial requirement object
   * @returns {TestRequirement} Complete requirement with defaults
   */
  createTestRequirement(requirement) {
    const now = new Date();
    return {
      id: requirement.id || `req_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
      objectType: requirement.objectType || 'table',
      targetName: requirement.targetName || '',
      requiredAssertions: requirement.requiredAssertions || [],
      priority: requirement.priority || 'medium',
      schema: requirement.schema || 'public',
      optional: requirement.optional || false,
      metadata: {
        description: '',
        tags: [],
        source: 'manual',
        estimatedEffort: 5,
        dependencies: [],
        autoGenerated: false,
        createdAt: now,
        version: '1.0.0',
        ...requirement.metadata
      }
    };
  },

  /**
   * Calculate severity score for a coverage gap
   * @param {CoverageGap} gap - Gap to score
   * @returns {number} Severity score (0-100)
   */
  calculateSeverityScore(gap) {
    const priorityWeights = {
      critical: 40,
      high: 30,
      medium: 20,
      low: 10
    };

    const baseScore = priorityWeights[gap.priority] || 10;
    const missingAssertionsWeight = Math.min(gap.missingAssertions.length * 5, 30);
    const typeWeight = gap.objectType === 'function' || gap.objectType === 'policy' ? 20 : 10;
    const criticalPathBonus = gap.metadata?.isCriticalPath ? 10 : 0;

    return Math.min(baseScore + missingAssertionsWeight + typeWeight + criticalPathBonus, 100);
  },

  // Constants for common patterns
  COMMON_TABLE_ASSERTIONS: ['has_table'],
  COMMON_COLUMN_ASSERTIONS: ['has_column', 'col_type_is'],
  COMMON_FUNCTION_ASSERTIONS: ['has_function', 'function_returns'],
  COMMON_INDEX_ASSERTIONS: ['has_index'],
  COMMON_POLICY_ASSERTIONS: ['policy_roles_are', 'policy_cmd_is'],
  COMMON_TRIGGER_ASSERTIONS: ['has_trigger', 'trigger_is'],

  DEFAULT_PRIORITY: 'medium',
  DEFAULT_SCHEMA: 'public',

  PRIORITY_LEVELS: ['critical', 'high', 'medium', 'low'],
  OBJECT_TYPES: ['table', 'column', 'function', 'index', 'policy', 'trigger', 'schema', 'view', 'constraint']
};
