// Database-focused Edge Function: {{functionName}}
// Generated by DATA CLI on {{timestamp}}
// Runtime: Deno {{denoVersion}} - Web API Only

import { createClient } from 'https://esm.sh/@supabase/supabase-js@2'

// Database client with elevated privileges for admin operations
const supabaseUrl = Deno.env.get('SUPABASE_URL')!
const supabaseServiceKey = Deno.env.get('SUPABASE_SERVICE_ROLE_KEY')!

if (!supabaseUrl || !supabaseServiceKey) {
  throw new Error('Missing required environment variables: SUPABASE_URL, SUPABASE_SERVICE_ROLE_KEY')
}

// Use service role key for database operations requiring elevated privileges
const supabase = createClient(supabaseUrl, supabaseServiceKey)

// CORS headers for browser compatibility
const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',
  'Access-Control-Allow-Methods': 'GET, POST, PUT, DELETE, OPTIONS',
}

/**
 * Database operation types supported by this function
 */
type DatabaseOperation = 'select' | 'insert' | 'update' | 'delete' | 'upsert' | 'count' | 'execute'

interface DatabaseRequest {
  operation: DatabaseOperation
  table: string
  data?: any
  filters?: Record<string, any>
  columns?: string
  options?: {
    limit?: number
    offset?: number
    orderBy?: string
    orderDirection?: 'asc' | 'desc'
  }
  sql?: string // For raw SQL execution
}

/**
 * Main database function handler
 */
Deno.serve(async (req: Request): Promise<Response> => {
  const startTime = performance.now()
  
  console.log(`[${new Date().toISOString()}] {{functionName}}: ${req.method} ${req.url}`)

  // Handle CORS preflight
  if (req.method === 'OPTIONS') {
    return new Response('ok', { headers: corsHeaders })
  }

  try {
    // Only allow POST requests for database operations
    if (req.method !== 'POST') {
      return new Response(
        JSON.stringify({ error: 'Only POST method is allowed for database operations' }),
        { 
          status: 405,
          headers: { 
            'Content-Type': 'application/json',
            'Allow': 'POST, OPTIONS',
            ...corsHeaders 
          }
        }
      )
    }

    // Parse and validate request
    let dbRequest: DatabaseRequest
    try {
      dbRequest = await req.json()
    } catch (error) {
      return new Response(
        JSON.stringify({ error: 'Invalid JSON in request body' }),
        { 
          status: 400,
          headers: { 'Content-Type': 'application/json', ...corsHeaders }
        }
      )
    }

    // Validate required fields
    if (!dbRequest.operation) {
      return new Response(
        JSON.stringify({ error: 'Missing required field: operation' }),
        { 
          status: 400,
          headers: { 'Content-Type': 'application/json', ...corsHeaders }
        }
      )
    }

    // Route to appropriate handler
    let result: any
    switch (dbRequest.operation) {
      case 'select':
        result = await handleSelect(dbRequest)
        break
      
      case 'insert':
        result = await handleInsert(dbRequest)
        break
      
      case 'update':
        result = await handleUpdate(dbRequest)
        break
      
      case 'delete':
        result = await handleDelete(dbRequest)
        break
      
      case 'upsert':
        result = await handleUpsert(dbRequest)
        break
      
      case 'count':
        result = await handleCount(dbRequest)
        break
      
      case 'execute':
        result = await handleExecute(dbRequest)
        break
      
      default:
        return new Response(
          JSON.stringify({ 
            error: `Unsupported operation: ${dbRequest.operation}`,
            supportedOperations: ['select', 'insert', 'update', 'delete', 'upsert', 'count', 'execute']
          }),
          { 
            status: 400,
            headers: { 'Content-Type': 'application/json', ...corsHeaders }
          }
        )
    }

    const duration = performance.now() - startTime
    console.log(`Operation ${dbRequest.operation} completed in ${duration.toFixed(2)}ms`)

    return new Response(
      JSON.stringify({
        success: true,
        operation: dbRequest.operation,
        data: result.data,
        count: result.count,
        duration: Math.round(duration),
        timestamp: new Date().toISOString()
      }),
      { 
        status: 200,
        headers: { 'Content-Type': 'application/json', ...corsHeaders }
      }
    )

  } catch (error) {
    const duration = performance.now() - startTime
    
    console.error('Database operation error:', {
      message: error.message,
      stack: error.stack,
      duration: Math.round(duration)
    })

    return new Response(
      JSON.stringify({
        error: 'Database operation failed',
        message: error.message,
        requestId: crypto.randomUUID(),
        timestamp: new Date().toISOString()
      }),
      { 
        status: 500,
        headers: { 'Content-Type': 'application/json', ...corsHeaders }
      }
    )
  }
})

/**
 * Handle SELECT operations
 */
async function handleSelect(request: DatabaseRequest) {
  if (!request.table) {
    throw new Error('Table name is required for select operations')
  }

  let query = supabase
    .from(request.table)
    .select(request.columns || '*', { count: 'exact' })

  // Apply filters
  if (request.filters) {
    Object.entries(request.filters).forEach(([column, value]) => {
      if (Array.isArray(value)) {
        query = query.in(column, value)
      } else if (typeof value === 'object' && value !== null) {
        // Support for operators like { gte: 10 }, { like: '%pattern%' }
        Object.entries(value).forEach(([operator, operatorValue]) => {
          query = (query as any)[operator](column, operatorValue)
        })
      } else {
        query = query.eq(column, value)
      }
    })
  }

  // Apply options
  if (request.options) {
    const { limit, offset, orderBy, orderDirection } = request.options
    
    if (limit) query = query.limit(limit)
    if (offset) query = query.range(offset, offset + (limit || 1000) - 1)
    if (orderBy) query = query.order(orderBy, { ascending: orderDirection !== 'desc' })
  }

  const { data, error, count } = await query

  if (error) throw error

  return { data, count }
}

/**
 * Handle INSERT operations
 */
async function handleInsert(request: DatabaseRequest) {
  if (!request.table || !request.data) {
    throw new Error('Table name and data are required for insert operations')
  }

  const { data, error } = await supabase
    .from(request.table)
    .insert(request.data)
    .select()

  if (error) throw error

  return { data, count: Array.isArray(data) ? data.length : (data ? 1 : 0) }
}

/**
 * Handle UPDATE operations
 */
async function handleUpdate(request: DatabaseRequest) {
  if (!request.table || !request.data || !request.filters) {
    throw new Error('Table name, data, and filters are required for update operations')
  }

  let query = supabase
    .from(request.table)
    .update(request.data)

  // Apply filters
  Object.entries(request.filters).forEach(([column, value]) => {
    query = query.eq(column, value)
  })

  const { data, error, count } = await query.select()

  if (error) throw error

  return { data, count }
}

/**
 * Handle DELETE operations
 */
async function handleDelete(request: DatabaseRequest) {
  if (!request.table || !request.filters) {
    throw new Error('Table name and filters are required for delete operations')
  }

  let query = supabase.from(request.table).delete()

  // Apply filters
  Object.entries(request.filters).forEach(([column, value]) => {
    query = query.eq(column, value)
  })

  const { data, error, count } = await query.select()

  if (error) throw error

  return { data, count }
}

/**
 * Handle UPSERT operations
 */
async function handleUpsert(request: DatabaseRequest) {
  if (!request.table || !request.data) {
    throw new Error('Table name and data are required for upsert operations')
  }

  const { data, error } = await supabase
    .from(request.table)
    .upsert(request.data)
    .select()

  if (error) throw error

  return { data, count: Array.isArray(data) ? data.length : (data ? 1 : 0) }
}

/**
 * Handle COUNT operations
 */
async function handleCount(request: DatabaseRequest) {
  if (!request.table) {
    throw new Error('Table name is required for count operations')
  }

  let query = supabase
    .from(request.table)
    .select('*', { count: 'exact', head: true })

  // Apply filters
  if (request.filters) {
    Object.entries(request.filters).forEach(([column, value]) => {
      query = query.eq(column, value)
    })
  }

  const { count, error } = await query

  if (error) throw error

  return { data: null, count }
}

/**
 * Handle raw SQL execution
 * WARNING: Use with extreme caution in production
 */
async function handleExecute(request: DatabaseRequest) {
  if (!request.sql) {
    throw new Error('SQL query is required for execute operations')
  }

  // Basic SQL injection protection (very basic - implement proper validation)
  const dangerousKeywords = ['DROP', 'TRUNCATE', 'DELETE FROM', 'ALTER', 'CREATE']
  const upperSQL = request.sql.toUpperCase()
  
  for (const keyword of dangerousKeywords) {
    if (upperSQL.includes(keyword)) {
      throw new Error(`Potentially dangerous SQL keyword detected: ${keyword}`)
    }
  }

  const { data, error } = await supabase.rpc('execute_sql', { 
    query: request.sql 
  })

  if (error) throw error

  return { data, count: Array.isArray(data) ? data.length : (data ? 1 : 0) }
}