// Webhook Handler Edge Function: {{functionName}}
// Generated by DATA CLI on {{timestamp}}
// Runtime: Deno {{denoVersion}} - Web API Only

{{#if supabaseIntegration}}
import { createClient } from 'https://esm.sh/@supabase/supabase-js@2'
{{/if}}

{{#if supabaseIntegration}}
// Supabase client for webhook event storage
const supabaseUrl = Deno.env.get('SUPABASE_URL')!
const supabaseKey = Deno.env.get('SUPABASE_SERVICE_ROLE_KEY') || Deno.env.get('SUPABASE_ANON_KEY')!

if (!supabaseUrl || !supabaseKey) {
  throw new Error('Missing Supabase configuration')
}

const supabase = createClient(supabaseUrl, supabaseKey)
{{/if}}

// Webhook configuration
const WEBHOOK_SECRETS = {
  github: Deno.env.get('GITHUB_WEBHOOK_SECRET'),
  stripe: Deno.env.get('STRIPE_WEBHOOK_SECRET'),
  default: Deno.env.get('WEBHOOK_SECRET') || 'default-secret-change-in-production'
}

// Supported webhook sources
type WebhookSource = 'github' | 'stripe' | 'generic' | 'custom'

interface WebhookEvent {
  id: string
  source: WebhookSource
  event_type: string
  payload: any
  headers: Record<string, string>
  signature?: string
  timestamp: string
  processed: boolean
  metadata?: any
}

/**
 * Main webhook handler
 */
Deno.serve(async (req: Request): Promise<Response> => {
  const startTime = performance.now()
  const requestId = crypto.randomUUID()
  
  console.log(`[${new Date().toISOString()}] {{functionName}} - Request ${requestId}: ${req.method} ${req.url}`)

  // Only allow POST requests for webhooks
  if (req.method !== 'POST') {
    return new Response(
      JSON.stringify({ error: 'Only POST method is allowed for webhooks' }),
      { 
        status: 405,
        headers: { 
          'Content-Type': 'application/json',
          'Allow': 'POST'
        }
      }
    )
  }

  try {
    // Extract request information
    const userAgent = req.headers.get('User-Agent') || 'unknown'
    const contentType = req.headers.get('Content-Type') || ''
    const signature = req.headers.get('X-Hub-Signature-256') || 
                     req.headers.get('Stripe-Signature') ||
                     req.headers.get('X-Signature')

    // Determine webhook source based on headers and user agent
    const source = determineWebhookSource(req.headers, userAgent)
    
    console.log(`Webhook source detected: ${source}`)

    // Get raw payload for signature verification
    const rawPayload = await req.text()
    
    // Verify webhook signature
    if (!await verifyWebhookSignature(source, rawPayload, signature)) {
      console.warn(`Invalid signature for ${source} webhook`)
      return new Response(
        JSON.stringify({ error: 'Invalid webhook signature' }),
        { 
          status: 401,
          headers: { 'Content-Type': 'application/json' }
        }
      )
    }

    // Parse payload
    let payload: any
    try {
      payload = contentType.includes('application/json') ? JSON.parse(rawPayload) : rawPayload
    } catch (error) {
      console.error('Failed to parse webhook payload:', error)
      return new Response(
        JSON.stringify({ error: 'Invalid payload format' }),
        { 
          status: 400,
          headers: { 'Content-Type': 'application/json' }
        }
      )
    }

    // Create webhook event record
    const webhookEvent: WebhookEvent = {
      id: requestId,
      source,
      event_type: extractEventType(source, payload, req.headers),
      payload,
      headers: Object.fromEntries(req.headers.entries()),
      signature,
      timestamp: new Date().toISOString(),
      processed: false,
      metadata: {
        user_agent: userAgent,
        content_type: contentType,
        payload_size: rawPayload.length
      }
    }

    {{#if supabaseIntegration}}
    // Store webhook event in database
    const { error: storeError } = await supabase
      .from('webhook_events')
      .insert([webhookEvent])

    if (storeError) {
      console.error('Failed to store webhook event:', storeError)
      // Continue processing even if storage fails
    }
    {{/if}}

    // Process the webhook based on source and event type
    const processingResult = await processWebhook(webhookEvent)

    {{#if supabaseIntegration}}
    // Update webhook event as processed
    if (processingResult.success) {
      await supabase
        .from('webhook_events')
        .update({ 
          processed: true,
          metadata: {
            ...webhookEvent.metadata,
            processing_duration: performance.now() - startTime,
            processing_result: processingResult
          }
        })
        .eq('id', requestId)
    }
    {{/if}}

    const duration = performance.now() - startTime
    console.log(`Webhook ${requestId} processed in ${duration.toFixed(2)}ms`)

    return new Response(
      JSON.stringify({
        success: true,
        request_id: requestId,
        source,
        event_type: webhookEvent.event_type,
        processed: processingResult.success,
        duration: Math.round(duration),
        timestamp: new Date().toISOString()
      }),
      { 
        status: 200,
        headers: { 'Content-Type': 'application/json' }
      }
    )

  } catch (error) {
    const duration = performance.now() - startTime
    
    console.error(`Webhook processing error (${requestId}):`, {
      message: error.message,
      stack: error.stack,
      duration: Math.round(duration)
    })

    return new Response(
      JSON.stringify({
        error: 'Webhook processing failed',
        request_id: requestId,
        message: error.message,
        timestamp: new Date().toISOString()
      }),
      { 
        status: 500,
        headers: { 'Content-Type': 'application/json' }
      }
    )
  }
})

/**
 * Determine webhook source based on headers and user agent
 */
function determineWebhookSource(headers: Headers, userAgent: string): WebhookSource {
  // GitHub webhooks
  if (headers.get('X-GitHub-Event') || userAgent.includes('GitHub-Hookshot')) {
    return 'github'
  }
  
  // Stripe webhooks
  if (headers.get('Stripe-Signature') || userAgent.includes('Stripe')) {
    return 'stripe'
  }
  
  // Custom webhook with specific header
  if (headers.get('X-Custom-Webhook')) {
    return 'custom'
  }
  
  return 'generic'
}

/**
 * Extract event type from payload and headers
 */
function extractEventType(source: WebhookSource, payload: any, headers: Headers): string {
  switch (source) {
    case 'github':
      return headers.get('X-GitHub-Event') || 'unknown'
    
    case 'stripe':
      return payload?.type || 'unknown'
    
    case 'custom':
      return headers.get('X-Event-Type') || payload?.event_type || 'custom_event'
    
    default:
      return payload?.event_type || payload?.type || 'generic_event'
  }
}

/**
 * Verify webhook signature based on source
 */
async function verifyWebhookSignature(
  source: WebhookSource, 
  payload: string, 
  signature?: string | null
): Promise<boolean> {
  if (!signature) {
    console.warn(`No signature provided for ${source} webhook`)
    return true // Allow unsigned webhooks in development
  }

  const secret = WEBHOOK_SECRETS[source] || WEBHOOK_SECRETS.default
  if (!secret) {
    console.warn(`No webhook secret configured for ${source}`)
    return true // Allow if no secret configured
  }

  try {
    switch (source) {
      case 'github':
        return await verifyGitHubSignature(payload, signature, secret)
      
      case 'stripe':
        return await verifyStripeSignature(payload, signature, secret)
      
      default:
        return await verifyHMACSignature(payload, signature, secret)
    }
  } catch (error) {
    console.error(`Signature verification failed for ${source}:`, error)
    return false
  }
}

/**
 * Verify GitHub webhook signature
 */
async function verifyGitHubSignature(payload: string, signature: string, secret: string): Promise<boolean> {
  const expectedSignature = 'sha256=' + await hmacSHA256(secret, payload)
  return signature === expectedSignature
}

/**
 * Verify Stripe webhook signature
 */
async function verifyStripeSignature(payload: string, signature: string, secret: string): Promise<boolean> {
  // Stripe signature format: t=timestamp,v1=signature
  const elements = signature.split(',')
  const signatureElement = elements.find(element => element.startsWith('v1='))
  
  if (!signatureElement) return false
  
  const stripeSignature = signatureElement.split('=')[1]
  const expectedSignature = await hmacSHA256(secret, payload)
  
  return stripeSignature === expectedSignature
}

/**
 * Verify generic HMAC signature
 */
async function verifyHMACSignature(payload: string, signature: string, secret: string): Promise<boolean> {
  const expectedSignature = await hmacSHA256(secret, payload)
  return signature === expectedSignature || signature === `sha256=${expectedSignature}`
}

/**
 * Generate HMAC-SHA256 signature
 */
async function hmacSHA256(secret: string, payload: string): Promise<string> {
  const encoder = new TextEncoder()
  const key = await crypto.subtle.importKey(
    'raw',
    encoder.encode(secret),
    { name: 'HMAC', hash: 'SHA-256' },
    false,
    ['sign']
  )
  
  const signature = await crypto.subtle.sign('HMAC', key, encoder.encode(payload))
  return Array.from(new Uint8Array(signature))
    .map(b => b.toString(16).padStart(2, '0'))
    .join('')
}

/**
 * Process webhook based on source and event type
 */
async function processWebhook(event: WebhookEvent): Promise<{ success: boolean; result?: any }> {
  try {
    console.log(`Processing ${event.source} webhook: ${event.event_type}`)

    switch (event.source) {
      case 'github':
        return await processGitHubWebhook(event)
      
      case 'stripe':
        return await processStripeWebhook(event)
      
      case 'custom':
        return await processCustomWebhook(event)
      
      default:
        return await processGenericWebhook(event)
    }
  } catch (error) {
    console.error('Webhook processing error:', error)
    return { success: false, result: { error: error.message } }
  }
}

/**
 * Process GitHub webhook events
 */
async function processGitHubWebhook(event: WebhookEvent): Promise<{ success: boolean; result?: any }> {
  const { event_type, payload } = event

  switch (event_type) {
    case 'push':
      console.log(`GitHub push to ${payload.repository?.full_name}: ${payload.commits?.length} commits`)
      // Add your GitHub push processing logic here
      break
    
    case 'pull_request':
      const action = payload.action
      const pr = payload.pull_request
      console.log(`GitHub PR ${action}: ${pr?.title} (#${pr?.number})`)
      // Add your PR processing logic here
      break
    
    case 'issues':
      const issue = payload.issue
      console.log(`GitHub issue ${payload.action}: ${issue?.title} (#${issue?.number})`)
      // Add your issue processing logic here
      break
    
    default:
      console.log(`Unhandled GitHub event: ${event_type}`)
  }

  return { success: true, result: { processed_event: event_type } }
}

/**
 * Process Stripe webhook events
 */
async function processStripeWebhook(event: WebhookEvent): Promise<{ success: boolean; result?: any }> {
  const { event_type, payload } = event

  switch (event_type) {
    case 'payment_intent.succeeded':
      console.log(`Stripe payment succeeded: ${payload.data?.object?.id}`)
      // Add your payment processing logic here
      break
    
    case 'customer.subscription.created':
      console.log(`Stripe subscription created: ${payload.data?.object?.id}`)
      // Add your subscription processing logic here
      break
    
    case 'invoice.payment_failed':
      console.log(`Stripe payment failed: ${payload.data?.object?.id}`)
      // Add your failed payment processing logic here
      break
    
    default:
      console.log(`Unhandled Stripe event: ${event_type}`)
  }

  return { success: true, result: { processed_event: event_type } }
}

/**
 * Process custom webhook events
 */
async function processCustomWebhook(event: WebhookEvent): Promise<{ success: boolean; result?: any }> {
  console.log(`Processing custom webhook event: ${event.event_type}`)
  
  // Add your custom webhook processing logic here
  // Example: send notifications, update database, trigger workflows
  
  return { success: true, result: { processed_event: event.event_type } }
}

/**
 * Process generic webhook events
 */
async function processGenericWebhook(event: WebhookEvent): Promise<{ success: boolean; result?: any }> {
  console.log(`Processing generic webhook event: ${event.event_type}`)
  
  // Add your generic webhook processing logic here
  
  return { success: true, result: { processed_event: event.event_type } }
}